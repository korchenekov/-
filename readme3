# Алгоритмы и структуры данных: сортировка и поиск

В этом документе представлены основные алгоритмы сортировки и поиска. Для каждого алгоритма приведены определение, принцип работы, пошаговое выполнение, оценка сложности и примеры работы.

---

## **Алгоритмы сортировки**

### 1. Сортировка выбором (Selection Sort)
**Определение:** Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в начало этой части.

**Как работает:**
1. Находим минимальный элемент в неотсортированной части
2. Меняем его местами с первым элементом неотсортированной части
3. Увеличиваем границу отсортированной части на один элемент
4. Повторяем до полной сортировки массива

**Сложность:** O(n²) для всех случаев

**Пример:**
```
Исходный массив: [23, 56, 21, 41, 12]
Отсортированный: [12, 21, 23, 41, 56]
```

### 2. Сортировка пузырьком (Bubble Sort)
**Определение:** Простой алгоритм, который многократно сравнивает и меняет местами соседние элементы, если они расположены в неправильном порядке.

**Как работает:**
1. Последовательно сравниваем соседние элементы
2. Если левый элемент больше правого - меняем их местами
3. После каждого прохода самый большой элемент "всплывает" в конец
4. Процесс повторяется до полной сортировки

**Сложность:**
- Худший случай: O(n²)
- Лучший случай: O(n)

**Пример:**
```
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный: [11, 12, 22, 25, 34, 64, 90]
```

### 3. Сортировка вставками (Insertion Sort)
**Определение:** Алгоритм, который последовательно вставляет каждый элемент в правильную позицию в уже отсортированной части массива.

**Как работает:**
1. Начинаем со второго элемента
2. Сравниваем текущий элемент с элементами в отсортированной части
3. Сдвигаем элементы больше текущего вправо
4. Вставляем текущий элемент на найденную позицию

**Сложность:**
- Худший случай: O(n²)
- Лучший случай: O(n)

**Пример:**
```
Исходный массив: [15, 8, 42, 4, 23, 16]
Отсортированный: [4, 8, 15, 16, 23, 42]
```

### 4. Сортировка слиянием (Merge Sort)
**Определение:** Алгоритм "разделяй и властвуй", который рекурсивно делит массив на части, сортирует их и объединяет.

**Как работает:**
1. Рекурсивно делим массив пополам
2. Сортируем каждую половину
3. Объединяем отсортированные части в один массив

**Сложность:** O(n log n) для всех случаев

**Пример:**
```
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный: [3, 9, 10, 27, 38, 43, 82]
```

### 5. Быстрая сортировка (Quick Sort)
**Определение:** Алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше и больше опорного.

**Как работает:**
1. Выбираем опорный элемент
2. Разделяем массив на элементы меньше и больше опорного
3. Рекурсивно применяем алгоритм к обеим частям

**Сложность:**
- Средний случай: O(n log n)
- Худший случай: O(n²)

**Пример:**
```
Исходный массив: [24, 15, 38, 2, 19, 41, 8]
Отсортированный: [2, 8, 15, 19, 24, 38, 41]
```

### 6. Пирамидальная сортировка (Heap Sort)
**Определение:** Алгоритм, использующий структуру данных "куча" для сортировки элементов.

**Как работает:**
1. Строим max-кучу из массива
2. Извлекаем максимальный элемент (корень) и помещаем в конец
3. Восстанавливаем свойства кучи
4. Повторяем процесс для уменьшенной кучи

**Сложность:** O(n log n) для всех случаев

**Пример:**
```
Исходный массив: [4, 10, 3, 5, 1]
Отсортированный: [1, 3, 4, 5, 10]
```

### 7. Сортировка Шелла (Shell Sort)
**Определение:** Улучшенная версия сортировки вставками, которая сравнивает элементы на определенном расстоянии.

**Как работает:**
1. Выбираем начальный шаг (gap)
2. Сортируем элементы на этом расстоянии методом вставок
3. Постепенно уменьшаем шаг до 1

**Сложность:** В среднем O(n log n)

**Пример:**
```
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Отсортированный: [1, 2, 3, 8, 12, 23, 34, 54]
```

---

## **Алгоритмы поиска**

### 1. Линейный поиск (Linear Search)
**Определение:** Последовательная проверка каждого элемента массива до нахождения искомого.

**Сложность:** O(n)

**Пример:**
```
Массив: [2, 5, 8, 12, 16, 23, 38, 45]
Элемент 16 найден на позиции 4
```

### 2. Бинарный поиск (Binary Search)
**Определение:** Эффективный алгоритм для отсортированных массивов, который делит область поиска пополам на каждом шаге.

**Сложность:** O(log n)

**Пример:**
```
Массив: [3, 7, 14, 21, 29, 33, 42, 55, 67, 78]
Элемент 29 найден на позиции 4
```

### 3. Интерполяционный поиск (Interpolation Search)
**Определение:** Улучшенный бинарный поиск для равномерно распределенных данных, который оценивает позицию искомого элемента.

**Сложность:**
- Средний случай: O(log log n)
- Худший случай: O(n)

**Пример:**
```
Массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Элемент 60 найден на позиции 5
```

### 4. Поиск Фибоначчи (Fibonacci Search)
**Определение:** Алгоритм, использующий числа Фибоначчи для определения точек разделения в отсортированном массиве.

**Сложность:** O(log n)

**Пример:**
```
Массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Элемент 85 найден на позиции 8
```
